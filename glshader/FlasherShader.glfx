////GLOBAL
#version 330

#include "Helpers.fxh"

#define Filter_None	    0.
#define Filter_Additive	1.
#define Filter_Overlay	2.
#define Filter_Multiply	3.
#define Filter_Screen   4.

////VERTEX

// transformation matrices
uniform float4x4 matWorldViewProj;

in vec3 vPosition;
in vec2 tc;

out vec2 tex0;

////FRAGMENT

uniform float4 staticColor_Alpha;
uniform float4 alphaTestValueAB_filterMode_addBlend; // last one bool
uniform float4 amount_blend_modulate_vs_add_hdrTexture01; // last two are bools

uniform sampler2D Texture0; // base texture
uniform sampler2D Texture1; // second image

in vec2 tex0;
out vec4 color;

////vs_simple_main

void main()
{
   gl_Position = mul(vec4(vPosition, 1.0), matWorldViewProj);
   tex0 = tc;
}

////ps_main_textureOne_noLight

void main()
{
   float4 pixel = tex2D(Texture0, tex0);

   if (pixel.a<=alphaTestValueAB_filterMode_addBlend.x)
    clip(-1);           //stop the pixel shader if alpha test should reject pixel

   if(amount_blend_modulate_vs_add_hdrTexture01.z == 0.)
       pixel.xyz = InvGamma(pixel.xyz);

   color.xyz = staticColor_Alpha.xyz*pixel.xyz;
   color.a = pixel.a*staticColor_Alpha.w;

   if(alphaTestValueAB_filterMode_addBlend.w != 0.)
      color = float4(color.xyz*(-amount_blend_modulate_vs_add_hdrTexture01.y*color.a), // negative as it will be blended with '1.0-thisvalue' (the 1.0 is needed to modulate the underlying elements correctly, but not wanted for the term below)
                    1.0/amount_blend_modulate_vs_add_hdrTexture01.y - 1.0);
}

////ps_main_textureAB_noLight

void main()
{
   float4 pixel1 = tex2D(Texture0, tex0);
   float4 pixel2 = tex2D(Texture1, tex0);

   if (pixel1.a<=alphaTestValueAB_filterMode_addBlend.x || pixel2.a<=alphaTestValueAB_filterMode_addBlend.y)
    clip(-1);           //stop the pixel shader if alpha test should reject pixel

   if(amount_blend_modulate_vs_add_hdrTexture01.z == 0.)
      pixel1.xyz = InvGamma(pixel1.xyz);
   if(amount_blend_modulate_vs_add_hdrTexture01.w == 0.)
      pixel2.xyz = InvGamma(pixel2.xyz);

   color = staticColor_Alpha;

   if ( alphaTestValueAB_filterMode_addBlend.z == Filter_Overlay )
      color *= OverlayHDR(pixel1,pixel2); // could be HDR
   else if ( alphaTestValueAB_filterMode_addBlend.z == Filter_Multiply )
      color *= Multiply(pixel1,pixel2, amount_blend_modulate_vs_add_hdrTexture01.x);
   else if ( alphaTestValueAB_filterMode_addBlend.z == Filter_Additive )
      color *= Additive(pixel1,pixel2, amount_blend_modulate_vs_add_hdrTexture01.x);
   else if ( alphaTestValueAB_filterMode_addBlend.z == Filter_Screen )
      color *= ScreenHDR(pixel1,pixel2); // could be HDR

   if(alphaTestValueAB_filterMode_addBlend.w != 0.)
      color = float4(color.xyz*(-amount_blend_modulate_vs_add_hdrTexture01.y*color.a), // negative as it will be blended with '1.0-thisvalue' (the 1.0 is needed to modulate the underlying elements correctly, but not wanted for the term below)
                    1.0/amount_blend_modulate_vs_add_hdrTexture01.y - 1.0);
}

////ps_main_noLight

void main()
{
	if(alphaTestValueAB_filterMode_addBlend.w == 0.)
      color = staticColor_Alpha;
	else
	  color = float4(staticColor_Alpha.xyz*(-amount_blend_modulate_vs_add_hdrTexture01.y*staticColor_Alpha.w), // negative as it will be blended with '1.0-thisvalue' (the 1.0 is needed to modulate the underlying elements correctly, but not wanted for the term below)
	                1.0/amount_blend_modulate_vs_add_hdrTexture01.y - 1.0);
}

////TECHNIQUES

basic_with_textureOne_noLight:P0:vs_simple_main():ps_main_textureOne_noLight()
basic_with_textureAB_noLight:P0:vs_simple_main():ps_main_textureAB_noLight()
basic_with_noLight:P0:vs_simple_main():ps_main_noLight()
